#+STARTUP: overview
#+TITLE: Emacs Configuration
#+AUTHOR: Brian O'Reilly
#+EMAIL: <fade@deepsky.com>
#+OPTIONS: toc:4 h:4
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;

* Introduction
  
  This is my emacs configuration entry point. It is written in the
  [[http://www.orgmode.org][literate programming style]] in this org-mode file. The embedded code
  blocks are extracted when the init.el file is loaded, and then the
  extracted files are loaded to complete the environmental
  configuration.

  Pieces of this configuration have been taken from Magnar Sveen,
  Sascha Chua, Uncle Dave, [[https://github.com/daviwil/emacs-from-scratch][David Wilson]] and a host of others referenced in various
  places on the internet, but primarily [[http://www.emacswiki.org][Emacs Wiki]].
  
* Personal Information

Obviously, you'll want to change this to match your personal credentials.

#+begin_src emacs-lisp
(setq user-full-name "Brian O'Reilly"
      user-mail-address "fade@deepsky.com")
#+end_src

* Theme
** Autothemer
#+begin_src emacs-lisp
  (use-package autothemer
    :ensure t)
#+end_src
** Emacs' startup screen is naf
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC
** Modus these are exemplars of theme packaging
#+begin_src emacs-lisp
  (use-package modus-vivendi-theme
    :ensure t)
#+end_src
** Testing the themes from Doom emacs

   #+begin_src emacs-lisp
     (use-package doom-themes
       :ensure t
       ;; :config (load-theme 'doom-dracula t)
       )
   #+end_src

** Colours On Terminal
   custom colour themes generally enhance my experience of writing
   inside emacs, but when that theme is applied to an instance running
   inside a terminal, the effect is really just terrible. This mode
   kind of approximates the effect of a graphical emacs frame, in a
   text console.
   
#+BEGIN_SRC emacs-lisp
(use-package color-theme-approximate
  :ensure t
  :config
  (unless (display-graphic-p)
    (autoload 'color-theme-approximate-on "color-theme-approximate")
    (color-theme-approximate-on)))
#+END_SRC

** Cursor tomfoolery
   A fun hack that is in practice unusable.
#+begin_src emacs-lisp

;; if this is set here, it is overwritten by the colour theme.
;; (set-cursor-color "yellow")

;; (when (display-graphic-p) 
;;   (progn
;;     (defvar blink-cursor-colors (list
;;                                  "dark slate blue"
;;                                  "medium slate blue"
;;                                  "light slate blue"
;;                                  "steel blue"
;;                                  "royal blue"
;;                                  "light blue"
;;                                  "cyan"
;;                                  "cyan1"
;;                                  "cyan2"
;;                                  "cyan3"
;;                                  "cyan4"
;;                                  "spring green"
;;                                  "yellow"
;;                                  "orange"
;;                                  "red"
;;                                  "hot pink")
;;       "On each blink the cursor will cycle to the next color in this list.")
    
;;     (setq blink-cursor-count 0)
;;     (setq blink-cursor-interval 0.3)
;;     (defun blink-cursor-timer-function ()
;;       "Zarza wrote this cyberpunk variant of timer `blink-cursor-timer'. 
;;      Warning: overwrites original version in `frame.el'.

;;      This one changes the cursor color on each blink. Define colors in `blink-cursor-colors'."

;;       (when (not (internal-show-cursor-p))
;;         (when (>= blink-cursor-count (length blink-cursor-colors))
;;           (setq blink-cursor-count 0))
;;         (set-cursor-color (nth blink-cursor-count blink-cursor-colors))
;;         (setq blink-cursor-count (+ 1 blink-cursor-count)))
;;       (internal-show-cursor nil (not (internal-show-cursor-p)))))
#+end_src

** DeepSky Theme
   Load the appropriate theme, and a utility for arbitrarily loading
   others.

#+begin_src emacs-lisp
(progn
  (load-theme 'deepsky t)
  (message "Loading theme deepsky")
  (set-face-attribute `mode-line nil
                      :box nil)
  (set-face-attribute `mode-line nil
                      :box nil)
  (set-cursor-color "yellow"))
#+end_src

#+begin_src emacs-lisp
(defun switch-theme (theme)
  "Disables any currently active themes and loads THEME."
  ;; This interactive call is taken from `load-theme'
  (interactive
   (list
    (intern (completing-read "Load custom theme: "
                             (mapc 'symbol-name
                                   (custom-available-themes))))))
  (let ((enabled-themes custom-enabled-themes))
    (mapc #'disable-theme custom-enabled-themes)
    (load-theme theme t)))

(defun disable-active-themes ()
  "Disables any currently active themes listed in `custom-enabled-themes'."
  (interactive)
  (mapc #'disable-theme custom-enabled-themes))

(bind-key "s-<f12>" 'switch-theme)
(bind-key "s-<f11>" 'disable-active-themes)
#+end_src

** Highlight line containing the point

#+BEGIN_SRC emacs-lisp
  (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))

  (defadvice hl-line-mode (after
                           dino-advise-hl-line-mode
                           activate compile)
    (set-face-attribute 'hl-line nil
                        :inherit nil
                        :background (face-background 'highlight))
    (set-face-background hl-line-face "1f1f1f"))
#+END_SRC

** Rainbow
   
Mostly useful if you are into web development or game development.
Every time emacs encounters a hexadecimal code that resembles a color,
it will automatically highlight it in the appropriate color. This is a
lot cooler than you may think.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  ;; apply this mode to all programming modes.
  :init
  (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

* Modeline
  
The modeline is the heart of emacs, it offers information at all
times, it's persistent and verbose enough to gain a full understanding
of modes and states you are in.

One modeline-related setting that is missing and is instead placed at
the bottom is =diminish=.

** All the icons!
   
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+end_src
   
** Spaceline!
   I may not use spacemacs, since I do not like evil-mode and find
   spacemacs incredibly bloated and slow, however it would be stupid not
   to acknowledge the best parts about it, the theme and their modified
   powerline setup.

   This enables spaceline, it looks better and works very well with my
   theme of choice.

   #+BEGIN_SRC emacs-lisp
     (if window-system
         (progn
           (use-package spaceline
             :ensure t
             :config
             (require 'spaceline-config)
             (setq spaceline-buffer-encoding-abbrev-p t)
             (setq spaceline-line-column-p t)
             (setq spaceline-line-p t)

             ;; setting the powerline-default-separator here breaks
             ;; spaceline due to the use of spaceline-spacemacs-theme.
             ;; ** following left for documentation reasons. **
             ;;Valid Values: alternate, arrow, arrow-fade, bar, box, brace, butt,
             ;;chamfer, contour, curve, rounded, roundstub, wave, zigzag, utf-8
             ;; (setq powerline-default-separator (quote roundstub))
             ;; (setq powerline-default-dsparator-dir '(right . left))
             (spaceline-spacemacs-theme)
             (spaceline-toggle-flycheck-info-off)
             (spaceline-toggle-flycheck-error-off)
             (spaceline-toggle-flycheck-warning-off)
             (spaceline-toggle-version-control-on))

           (use-package spaceline-all-the-icons
             :ensure t
             :after spaceline
             :config
             (spaceline-all-the-icons-theme))))
   #+END_SRC
   
** No separator!
 #+BEGIN_SRC emacs-lisp
 (setq powerline-default-separator nil)
 #+END_SRC

** Cursor position

   Show the current line and column for your cursor. We are not going to
have =relative-linum-mode= in every major mode, so this is useful.

#+BEGIN_SRC emacs-lisp
  (setq line-number-mode t)
  (setq column-number-mode t)
#+END_SRC

** Clock
If you prefer the 12hr-format, change the variable to =nil= instead of =t=.

*** Time format
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (setq display-time-format "%H:%M - %d %B %Y")
#+END_SRC

*** Enabling the mode
This turns on the clock globally.
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC

** Battery indicator
A package called =fancy-battery= will be used if we are in GUI emacs,
otherwise the built in battery-mode will be used. Fancy battery has
very odd colors if used in the tty, hence us disabling it.
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :config
      (setq fancy-battery-show-percentage t)
      (setq battery-update-interval 15)
      (if window-system
        (fancy-battery-mode)
        (display-battery-mode)))
#+END_SRC

** System monitor
#+BEGIN_SRC emacs-lisp
(use-package symon
  :ensure t
  :bind
  ("s-h" . symon-mode))
#+END_SRC   

* Font
And here's how we tell Emacs which font we want.

#+begin_src emacs-lisp

  (if window-system
      (progn
        (set-face-attribute 'default nil :font "Envy Code R" :height 140)
        (set-face-attribute 'fixed-pitch nil :font "Envy Code R-12")
        ;; (set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height 120)
        (set-face-attribute 'variable-pitch nil :font "Cantarell" :height 130 :weight 'regular)))

#+end_src

* Which Key
[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix.  For example, if you press =C-c= (hold control and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run.  This is very useful for learning the possible key bindings in the mode of your current buffer.

  #+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 1))
  #+end_src

* Sane defaults

#+BEGIN_SRC emacs-lisp

(use-package diminish
  :ensure t)

#+END_SRC
  
Sources for this section include [[https://github.com/magnars/.emacs.d/blob/master/settings/sane-defaults.el][Magnar Sveen]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]].

#+begin_src emacs-lisp
  ;; These functions are useful. Activate them.
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)

  ;; Answering just 'y' or 'n' will do
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; Keep all backup and auto-save files in one directory
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

  ;; UTF-8 please
  (setq locale-coding-system 'utf-8) ; pretty
  (set-terminal-coding-system 'utf-8) ; pretty
  (set-keyboard-coding-system 'utf-8) ; pretty
  (set-selection-coding-system 'utf-8) ; please
  (prefer-coding-system 'utf-8) ; with sugar on top

  ;; tabs never in code. 
  (setq-default indent-tabs-mode nil)
  (setq-default indicate-empty-lines t)

  ;; Don't count two spaces after a period as the end of a sentence.
  ;; Just one space is needed.
  (setq sentence-end-double-space nil)

  ;; delete the region when typing, as is conventional these days.
  (delete-selection-mode t)

  (show-paren-mode t)

  (column-number-mode t)

  (global-visual-line-mode)
  (diminish 'visual-line-mode)

  (setq uniquify-buffer-name-style 'forward)

  ;; -i gets alias definitions from .bash_profile
  (setq shell-command-switch "-ic")

  ;; Don't beep at me
  (setq visible-bell t)
#+end_src

The following function for ~occur-dwim~ is taken from [[https://github.com/abo-abo][Oleh Krehel]] from
[[http://oremacs.com/2015/01/26/occur-dwim/][his blog post at (or emacs irrelevant)]]. It takes the current region or
the symbol at point as the default value for occur.

#+begin_src emacs-lisp
(defun occur-dwim ()
  "Call `occur' with a sane default."
  (interactive)
  (push (if (region-active-p)
            (buffer-substring-no-properties
             (region-beginning)
             (region-end))
          (thing-at-point 'symbol))
        regexp-history)
  (call-interactively 'occur))

(bind-key "M-s o" 'occur-dwim)
#+end_src

Here we make page-break characters look pretty, instead of appearing
as =^L= in Emacs. [[https://ericjmritz.wordpress.com/2015/08/29/using-page-breaks-in-gnu-emacs/][Here's an informative article called "Using
Page-Breaks in GNU Emacs" by Eric J. M. Ritz.]]

#+begin_src emacs-lisp
;; (use-package page-break-lines
;;   :ensure t)
#+end_src

in dired mode, it is useful to mark a bunch of files and then open
them all in separate buffers. Function implementation taken from Stack
Overflow, here: [[https://stackoverflow.com/questions/1110118/in-emacs-dired-how-to-find-visit-multiple-files][In Emacs dired, how to find/visit multiple files?]]

#+BEGIN_SRC emacs-lisp
(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "F" 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the
point, or when prefix arg, the next N files. "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))))
#+END_SRC

* Mac customizations

There are configurations to make when running Emacs on macOS (hence the
"darwin" system-type check).

#+begin_src emacs-lisp
(when (string-equal system-type "darwin")
  ;; delete files by moving them to the trash
  (setq delete-by-moving-to-trash t)
  (setq trash-directory "~/.Trash")

  ;; Don't make new frames when opening a new file with Emacs
  (setq ns-pop-up-frames nil)

  ;; set the Fn key as the hyper key
  (setq ns-function-modifier 'hyper)

  ;; Use Command-` to switch between Emacs windows (not frames)
  (bind-key "s-`" 'other-window)
  
  ;; Use Command-Shift-` to switch Emacs frames in reverse
  (bind-key "s-~" (lambda() () (interactive) (other-window -1)))

  ;; Because of the keybindings above, set one for `other-frame'
  (bind-key "s-1" 'other-frame)

  ;; Fullscreen!
  (setq ns-use-native-fullscreen nil) ; Not Lion style
  (bind-key "<s-return>" 'toggle-frame-fullscreen)

  ;; buffer switching
  (bind-key "s-{" 'previous-buffer)
  (bind-key "s-}" 'next-buffer)

  ;; Compiling
  (bind-key "H-c" 'compile)
  (bind-key "H-r" 'recompile)
  (bind-key "H-s" (defun save-and-recompile () (interactive) (save-buffer) (recompile)))

  ;; disable the key that minimizes emacs to the dock because I don't
  ;; minimize my windows
  ;; (global-unset-key (kbd "C-z"))

  (defun open-dir-in-finder ()
    "Open a new Finder window to the path of the current buffer"
    (interactive)
    (start-process "mai-open-dir-process" nil "open" "."))
  (bind-key "C-c o f" 'open-dir-in-finder)

  (defun open-dir-in-iterm ()
    "Open the current directory of the buffer in iTerm."
    (interactive)
    (let* ((iterm-app-path "/Applications/iTerm.app")
           (iterm-brew-path "/opt/homebrew-cask/Caskroom/iterm2/1.0.0/iTerm.app")
           (iterm-path (if (file-directory-p iterm-app-path)
                           iterm-app-path
                         iterm-brew-path)))
      (start-process "mai-open-dir-process" nil "open" "-a" iterm-path ".")))
  (bind-key "C-c o t" 'open-dir-in-iterm)

  ;; Not going to use these commands
  (put 'ns-print-buffer 'disabled t)
  (put 'suspend-frame 'disabled t))
#+end_src

~exec-path-from-shell~ makes the command-line path with Emacs's shell
match the same one on macOS.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :ensure t
  :init
  (exec-path-from-shell-initialize))
#+end_src

** El Capitan fixes

[[http://stuff-things.net/2015/10/05/emacs-visible-bell-work-around-on-os-x-el-capitan/][El Capitan Fixes]]

#+BEGIN_SRC emacs-lisp
  (cond
   ((string-equal system-type "darwin")
    (let* ((cmd "sw_vers -productVersion")
           (macos-version (string-to-number
                           (cadr (split-string
                                  (shell-command-to-string cmd)
                                  "\\."))))
           (elcapitan-version 11))
      (when (>= macos-version elcapitan-version)
        (setq visible-bell nil)
        (setq ring-bell-function 'ignore)

        ;; El Capitan full screen animation is quick and delightful (enough to start using it).
        (setq ns-use-native-fullscreen t))))
   ;; other system specific things in separate test subclauses
   ((string-equal system-type "gnu/linux")
    (progn
      (message "Gnu Linux System!")))
   ((string-equal system-type "windows-nt")
    (progn
      (message "Oh dear... you're using Windows. :("))))
#+END_SRC

* Projectile
Projectile is an awesome project manager, mostly because it recognizes
directories with a =.git= directory as projects and helps you manage
them accordingly.

** Enable projectile globally
This makes sure that everything can be a project.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
      (projectile-mode 1))
#+END_SRC

** Let projectile call make
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") 'projectile-compile-project)
#+END_SRC

* Default web browser
Taken, with thanks, from [[https://github.com/dakrone/eos/blob/master/eos-web.org][dakrone/eos at github]].

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x m") 'browse-url-at-point)

(use-package eww
  :defer t
  :init
  (setq browse-url-browser-function
        '((".*google.*maps.*" . browse-url-generic)
          ;; Github goes to firefox, but not gist
          ("http.*\/\/github.com" . browse-url-generic)
          ("groups.google.com" . browse-url-generic)
          ("docs.google.com" . browse-url-generic)
          ("melpa.org" . browse-url-generic)
          ("build.*\.elastic.co" . browse-url-generic)
          (".*-ci\.elastic.co" . browse-url-generic)
          ("internal-ci\.elastic\.co" . browse-url-generic)
          ("zendesk\.com" . browse-url-generic)
          ("salesforce\.com" . browse-url-generic)
          ("stackoverflow\.com" . browse-url-generic)
          ("apache\.org\/jira" . browse-url-generic)
          ("thepoachedegg\.net" . browse-url-generic)
          ("zoom.us" . browse-url-generic)
          ("t.co" . browse-url-generic)
          ("twitter.com" . browse-url-generic)
          ("\/\/a.co" . browse-url-generic)
          ("youtube.com" . browse-url-generic)
          ("amazon.com" . browse-url-generic)
          ("slideshare.net" . browse-url-generic)
          ("." . eww-browse-url)))
  (setq shr-external-browser 'browse-url-generic)
  (setq browse-url-generic-program (executable-find "firefox"))
  (add-hook 'eww-mode-hook #'toggle-word-wrap)
  (add-hook 'eww-mode-hook #'visual-line-mode)
  :config
  (use-package s :ensure t)
  (define-key eww-mode-map "o" 'eww)
  (define-key eww-mode-map "O" 'eww-browse-with-external-browser)
  (define-key eww-mode-map "j" 'next-line)
  (define-key eww-mode-map "k" 'previous-line)

  (use-package eww-lnum
    :ensure t
    :config
    (bind-key "f" #'eww-lnum-follow eww-mode-map)
    (bind-key "U" #'eww-lnum-universal eww-mode-map)))

(defun browse-last-url-in-brower ()
  (interactive)
  (save-excursion
    (ffap-next-url t t)))

(global-set-key (kbd "C-c u") 'browse-last-url-in-brower)
#+END_SRC

* Dashboard

  This is your new startup screen, together with projectile it works in
unison and provides you with a quick look into your latest projects
and files. Change the welcome message to whatever string you want and
change the numbers to suit your liking, I find 5 to be enough.

#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
      (dashboard-setup-startup-hook)
      (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
      (setq dashboard-items '((recents  . 5)
                              (projects . 5)))
      (setq dashboard-banner-logo-title "DeepSky Emacs"))
#+END_SRC

* The terminal
** Default shell should be zsh
Don't ask me what shell I want to use. In general this is a solved problem..
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/usr/bin/zsh")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

* Moving around in emacs

  Spending too much time flapping around between buffers, stuck in the
interstitial space where work goes to die.

** swiper and why is the default search so lame
   
   I like me some searching, the default search is very meh. In emacs,
you mostly use search to get around your buffer, much like with avy,
but sometimes it doesn't hurt to search for entire words or modes,
swiper makes sure this is more efficient.

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind ("C-s" . 'swiper))
#+END_SRC

* List buffers

source: http://ergoemacs.org/emacs/emacs_buffer_management.html

Auto-revert-mode updates buffers so that they reflect what is on the
disk. This is particularly useful in the presence of git or other
version control software which can change the files from beneath the
buffers in emacs. source: [[http://whattheemacsd.com/sane-defaults.el-01.html][Magnar Sveen]]

#+begin_src emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
(global-auto-revert-mode t)

;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+end_src

* Recentf

#+begin_src emacs-lisp
(use-package recentf
  :bind ("C-x C-r" . helm-recentf)
  :config
  (recentf-mode t)
  (setq recentf-max-saved-items 200))
#+end_src


* Org mode

Org mode is one of the killer applications that run inside Emacs. It turns plain text into data that can be used for computation. Often, that computation takes the form of making lists and organising your life, but it can be anything you can conceive that is ultimately computable.

It goes without saying that I also use it to manage my Emacs config.

** Installation

Although Org mode ships with Emacs, the latest version can be installed externally. The configuration here follows the [[http://orgmode.org/elpa.html][Org mode ELPA installation instructions]].

#+BEGIN_SRC emacs-lisp

  (defun efs/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1))

  (use-package org
    :hook (org-mode . efs/org-mode-setup)
    :defer t
    :ensure org-plus-contrib
    :custom
    (org-ellipsis " ▾")
    (org-agenda-start-with-log-mode t)
    (org-log-done 'time)
    (org-log-into-drawer t)
    (org-todo-keywords
     '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
          (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))
    :config
    (progn (eval-after-load "org"
             '(require 'ox-md nil t))
           (setq org-support-shift-select 'always)))

#+END_SRC

On Org mode version 9 I wasn't able to execute source blocks out of
the box. [[https://emacs.stackexchange.com/a/28604][Others have ran into the same issue too]]. The solution is to
remove the .elc files from the package directory:

#+BEGIN_SRC sh :var ORG_DIR=(let* ((org-v (cadr (split-string (org-version nil t) "@"))) (len (length org-v))) (substring org-v 1 (- len 2)))
rm ${ORG_DIR}/*.elc
#+END_SRC

** Better Font Faces

The =efs/org-font-setup= function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in =org-mode=.  We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

#+begin_src emacs-lisp
  (defun efs/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

  (efs/org-font-setup)
#+end_src

** Org setup

Speed commands are a nice and quick way to perform certain actions
while at the beginning of a heading. It's not activated by default.

See the doc for speed keys by checking out [[elisp:(info%20"(org)%20speed%20keys")][the documentation for
speed keys in Org mode]].

#+begin_src emacs-lisp
(setq org-use-speed-commands t)
(require 'org-tempo)
#+end_src

#+begin_src emacs-lisp
(setq org-image-actual-width 550)
#+end_src

#+BEGIN_SRC emacs-lisp
(setq org-highlight-latex-and-related '(latex script entities))
#+END_SRC

#+begin_src emacs-lisp
  (setq org-refile-targets
    '(("Archive.org" :maxlevel . 1)
      ("Tasks.org" :maxlevel . 1)))

  ;; Save Org buffers after refiling!
  (advice-add 'org-refile :after 'org-save-all-org-buffers)
#+end_src

** Org capture

#+begin_src emacs-lisp
(bind-key "C-c c" 'org-capture)
(setq org-default-notes-file "~/Dropbox/Notes/notes.org")
#+end_src
** Org agenda

Learned about [[https://github.com/sachac/.emacs.d/blob/83d21e473368adb1f63e582a6595450fcd0e787c/Sacha.org#org-agenda][this =delq= and =mapcar= trick from Sacha Chua's config]]. This form will add the agenda file to the org-agenda-files list if the file actually exists at the place indicated. Remember to touch the file if you change this list.

#+begin_src emacs-lisp
  (setq org-agenda-files
        (delq nil
              (mapcar (lambda (x) (and (file-exists-p x) x))
                      (list (expand-file-name "personal-agenda.org" site-org-files)
                            (expand-file-name "notes.org" site-org-files)
                            (expand-file-name "todos.org" site-org-files)
                            (expand-file-name "Tasks.org" site-org-files)
                            (expand-file-name "people.org" site-org-files)
                            (expand-file-name "Archive.org" site-org-files)))))
#+end_src
** Org Roam
#+begin_src emacs-lisp

  (use-package org-roam
    :ensure t
    :after org)

  (use-package company-org-roam
    :ensure t
    :after org)

  (use-package  org-roam-bibtex
    :ensure t
    :after org-roam)

  (use-package org-roam-server
    :ensure t
    :after org-roam)

#+end_src
** Org activation bindings

Set up some global key bindings that integrate with Org Mode features.

#+begin_src emacs-lisp
(bind-key "C-c l" 'org-store-link)
(bind-key "C-c c" 'org-capture)
(bind-key "C-c a" 'org-agenda)
#+end_src

** Center Org Buffers

[[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] will center =org-mode= buffers. This gives a more pleasing effect when writing long documents in natural languages.

#+begin_src emacs-lisp
(defun efs/org-mode-visual-fill ()
  (setq visual-fill-column-width 100
        visual-fill-column-center-text t)
  (visual-fill-column-mode 1))

(use-package visual-fill-column
  :after org
  :ensure t
  :hook (org-mode . efs/org-mode-visual-fill))
#+end_src

** Org Bullets
Makes it all look a bit nicer, I hate looking at asterisks.  Also, see =org-mode-setup= configuration function at the top of this file.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
#+END_SRC

** Org tags

The default value is -77, which is weird for smaller width windows.
I'd rather have the tags align horizontally with the header. 45 is a
good column number to do that.

#+begin_src emacs-lisp
  (setq org-tags-column 45)

  (setq org-tag-alist
        '((:startgroup)
                                          ; Put mutually exclusive tags here
          (:endgroup)
          ("@errand" . ?E)
          ("@home" . ?H)
          ("@work" . ?W)
          ("agenda" . ?a)
          ("planning" . ?p)
          ("publish" . ?P)
          ("batch" . ?b)
          ("note" . ?n)
          ("idea" . ?i)))

  ;; Configure custom agenda views
  (setq org-agenda-custom-commands
        '(("d" "Dashboard"
           ((agenda "" ((org-deadline-warning-days 7)))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks")))
            (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

          ("n" "Next Tasks"
           ((todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks")))))

          ("W" "Work Tasks" tags-todo "+work-email")

          ;; Low-effort next actions
          ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
           ((org-agenda-overriding-header "Low Effort Tasks")
            (org-agenda-max-todos 20)
            (org-agenda-files org-agenda-files)))

          ("w" "Workflow Status"
           ((todo "WAIT"
                  ((org-agenda-overriding-header "Waiting on External")
                   (org-agenda-files org-agenda-files)))
            (todo "REVIEW"
                  ((org-agenda-overriding-header "In Review")
                   (org-agenda-files org-agenda-files)))
            (todo "PLAN"
                  ((org-agenda-overriding-header "In Planning")
                   (org-agenda-todo-list-sublevels nil)
                   (org-agenda-files org-agenda-files)))
            (todo "BACKLOG"
                  ((org-agenda-overriding-header "Project Backlog")
                   (org-agenda-todo-list-sublevels nil)
                   (org-agenda-files org-agenda-files)))
            (todo "READY"
                  ((org-agenda-overriding-header "Ready for Work")
                   (org-agenda-files org-agenda-files)))
            (todo "ACTIVE"
                  ((org-agenda-overriding-header "Active Projects")
                   (org-agenda-files org-agenda-files)))
            (todo "COMPLETED"
                  ((org-agenda-overriding-header "Completed Projects")
                   (org-agenda-files org-agenda-files)))
            (todo "CANC"
                  ((org-agenda-overriding-header "Cancelled Projects")
                   (org-agenda-files org-agenda-files)))))))
#+end_src

** Org Capture Templates

#+begin_src emacs-lisp
  (use-package doct
    :ensure t)
#+end_src

#+begin_src emacs-lisp
  (setq org-capture-templates
      `(("t" "Tasks / Projects")
        ("tt" "Task" entry (file+olp "~/Dropbox/OrgFiles/Tasks.org" "Inbox")
             "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

        ("j" "Journal Entries")
        ("jj" "Journal" entry
             (file+olp+datetree "~/Dropbox/OrgFiles/Journal.org")
             "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
             ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
             :clock-in :clock-resume
             :empty-lines 1)
        ("jm" "Meeting" entry
             (file+olp+datetree "~/Dropbox/OrgFiles/Journal.org")
             "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
             :clock-in :clock-resume
             :empty-lines 1)

        ("w" "Workflows")
        ("we" "Checking Email" entry (file+olp+datetree "~/Dropbox/OrgFiles/Journal.org")
             "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

        ;; ("m" "Metrics Capture")
        ;; ("mw" "Weight" table-line (file+headline "~/Dropbox/OrgFiles/Metrics.org" "Weight")
        ;;  "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)
        ))
#+end_src

** Org babel languages

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (C . t)
   (calc . t)
   (latex . t)
   (java . t)
   (ruby . t)
   (lisp . t)
   (scheme . t)
   (shell . t)
   (sqlite . t)
   (js . t)))
   

(defun my-org-confirm-babel-evaluate (lang body)
  "Do not confirm evaluation for these languages."
  (not (or (string= lang "C")
           (string= lang "java")
           (string= lang "python")
           (string= lang "emacs-lisp")
           (string= lang "sqlite"))))
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+end_src

** Org babel/source blocks

I like to have source blocks properly syntax highlighted and with the
editing popup window staying within the same window so all the windows
don't jump around. Also, having the top and bottom trailing lines in
the block is a waste of space, so we can remove them.

I noticed that fontification doesn't work with markdown mode when the
block is indented after editing it in the org src buffer---the leading
#s for headers don't get fontified properly because they appear as Org
comments. Setting ~org-src-preserve-indentation~ makes things
consistent as it doesn't pad source blocks with leading spaces.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t
      org-src-window-setup 'current-window
      org-src-strip-leading-and-trailing-blank-lines t
      ;; org-src-preserve-indentation t
      org-src-tab-acts-natively t)
#+end_src

** Org exporting

*** Pandoc exporter
Pandoc converts between a huge number of different file formats. 

#+begin_src emacs-lisp
(use-package ox-pandoc
  :no-require t
  :defer 10
  :ensure t)
#+end_src

*** LaTeX exporting

I've had issues with getting BiBTeX to work correctly with the LaTeX
exporter for PDF exporting. By changing the command to `latexmk`
references appear in the PDF output like they should. Source:
http://tex.stackexchange.com/a/161619.

#+BEGIN_SRC emacs-lisp
(setq org-latex-pdf-process (list "latexmk -pdf %f"))
#+END_SRC

exporting to html sometimes (always?) requires htmlize

#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t)
#+END_SRC


* Tramp

#+begin_src emacs-lisp
  (use-package tramp
    :ensure t)
#+end_src

* Window

Convenient keybindings to resize windows.

#+begin_src emacs-lisp
;; (bind-key "s-C-<left>"  'shrink-window-horizontally)
;; (bind-key "s-C-<right>" 'enlarge-window-horizontally)
;; (bind-key "s-C-<down>"  'shrink-window)
;; (bind-key "s-C-<up>"    'enlarge-window)
#+end_src

Whenever I split windows, I usually do so and also switch to the other
window as well, so might as well rebind the splitting key bindings to
do just that to reduce the repetition.

#+begin_src emacs-lisp
(defun vsplit-other-window ()
  "Splits the window vertically and switches to that window."
  (interactive)
  (split-window-vertically)
  (other-window 1 nil))
(defun hsplit-other-window ()
  "Splits the window horizontally and switches to that window."
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil))

(bind-key "C-x 2" 'vsplit-other-window)
(bind-key "C-x 3" 'hsplit-other-window)
#+end_src

* Whitespace mode
Because sometimes you have to look at python code that came from a person with unusual editor defaults.
#+begin_src emacs-lisp
(use-package whitespace
  :bind ("s-<f10>" . whitespace-mode))
#+end_src

* File Management
** Dired
Dired configuration is split between =init.el= and this clause in =config.org=, for reasons related to the way that emacs is initialised in this regime. If dired is not configured early, emacs throws to the debugger with an error when dired is called in regular use.
#+begin_src emacs-lisp
  (use-package dired-single
    :ensure t
    :after dired)

  (use-package all-the-icons-dired
    :ensure t
    :after dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

#+RESULTS:
| dired-extra-startup | all-the-icons-dired-mode | auto-revert-mode |

* Minor conveniences
Emacs is at it's best when it just does things for you, shows you the
way, guides you so to speak. This can be best achieved using a number
of small extensions. While on their own they might not be particularly
impressive. Together they create a nice environment for you to work
in.

** Visiting the configuration
Quickly edit =~/.emacs.d/config.org=

#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

** Reloading the configuration
Simply pressing =Control-c r= will reload this file, very handy.
You can also manually invoke =config-reload=.

#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    "Reloads ~/.emacs.d/config.org at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC

** Subwords
Emacs treats camelCase strings as a single word by default, this
changes said behaviour.

#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

** Beacon
While changing buffers or workspaces, the first thing you do is look
for your cursor. Unless you know its position, you can not move it
efficiently. Every time you change buffers, the current position of
your cursor will be briefly highlighted now.

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :config
  (beacon-mode 1))
#+END_SRC


* ELPA packages

These are the packages that are neither built into Emacs nor required to achieve the base configuration state. feel free to add or remove as many or as few of these as you want; they generally reflect my own biases and developmental requirements, so it is unlikely that this list will be perfectly harmonic with your own needs.

** Ag -- The Silver Searcher.

#+BEGIN_SRC emacs-lisp
(use-package ag
  :commands ag
  :ensure t
  :config
  (setq ag-highlight-search t
        ag-reuse-window nil
        ag-reuse-buffers t))
#+END_SRC

** Ace Jump Mode

A quick way to jump around text in buffers.

[[http://emacsrocks.com/e10.html][See Emacs Rocks Episode 10 for a screencast.]]

#+begin_src emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :diminish ace-jump-mode
  :commands ace-jump-mode
  :bind ("C-s-." . ace-jump-mode))
#+end_src

** Ace Window

[[https://github.com/abo-abo/ace-window][ace-window]] is a package that uses the same idea from ace-jump-mode for
buffer navigation, but applies it to windows. The default keys are
1-9.

#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    (ace-window-display-mode)
    :bind ("s-o" . ace-window))
#+end_src

** Android mode

#+begin_src emacs-lisp
(use-package android-mode
  :ensure t
  :defer t)
#+end_src
** C-Eldoc
   :PROPERTIES:
   :GitHub:   https://github.com/mooz/c-eldoc
   :END:

This package displays function signatures in the mode line.

#+begin_src emacs-lisp
(use-package c-eldoc
  :commands c-turn-on-eldoc-mode
  :ensure t
  :init (add-hook 'c-mode-hook #'c-turn-on-eldoc-mode))
#+end_src

** Clojure

#+begin_src emacs-lisp
(use-package clojure-mode
  :defer t
  :ensure t)
#+end_src

** Company
#+begin_src emacs-lisp
(use-package company
  :ensure nil
  :diminish company-mode
  ;; :bind (:map company-mode-map
  ;;             (("C-n" . company-select-next)
  ;;              ("C-p" . company-select-previous)
  ;;              ("C-d" . company-show-doc-buffer)
  ;;              ("M-." . company-show-location)))
  :config
  (progn
    ;; less than this and it disrupts typing when you aren't interested in completion.
    (setq company-idle-delay 0.3)
    (setq company-minimize-prefix-length 2)
    ;; company completion everywhere.
    (add-hook 'after-init-hook 'global-company-mode)
    (require 'color)
    
    (let ((bg (face-attribute 'default :background)))
      (custom-set-faces
       `(company-tooltip ((t (:inherit default :background ,(color-lighten-name bg 2)))))
       `(company-scrollbar-bg ((t (:background ,(color-lighten-name bg 10)))))
       `(company-scrollbar-fg ((t (:background ,(color-lighten-name bg 5)))))
       `(company-tooltip-selection ((t (:inherit font-lock-function-name-face))))
       `(company-tooltip-common ((t (:inherit font-lock-constant-face))))))
    
    (with-eval-after-load 'company
      (define-key company-active-map (kbd "M-n") nil)
      (define-key company-active-map (kbd "M-p") nil)
      (define-key company-active-map (kbd "C-n") #'company-select-next)
      (define-key company-active-map (kbd "C-p") #'company-select-previous)
      (define-key company-active-map (kbd "SPC") #'company-abort))))
#+end_src

** CSV mode
   #+begin_src emacs-lisp
     (use-package csv-mode
       :ensure t)
   #+end_src

** flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))

(use-package flycheck-cython
  :ensure t
  :after flycheck)

(use-package flycheck-clojure
  :ensure t
  :init (flycheck-clojure-setup))

(use-package flycheck-nim
  :ensure t
  :after flycheck)
#+end_src
   
** Undotree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :config
  (global-undo-tree-mode))
#+END_SRC

** Helm

#+begin_src emacs-lisp
(use-package helm
  :ensure t
  :diminish helm-mode
  :init (progn
          (use-package helm-config)
          (setq helm-locate-command "mdfind -interpret -name %s %s"
                helm-ff-newfile-prompt-p nil
                helm-M-x-fuzzy-match t)
          (helm-mode))
  
  :bind ((:map helm-map
               ("<tab>" . helm-execute-persistent-action)
               ("C-c h" . helm-command-prefix)
               ("C-x b" . helm-mini)
               ("C-x C-b" . 'helm-buffers-list)
               ("C-`" . helm-resume)))
  :bind*   (("M-x" . helm-M-x)
            ("C-x C-f" . helm-find-files))) 

(use-package helm-ag
  :defer 10
  :ensure t
  :after helm
  :bind ("C-c M-s" . helm-do-ag)
  :config
  (custom-set-variables
   '(helm-ag-base-command "ag --nocolor --nogroup --ignore-case")
   '(helm-ag-command-option "--all-text")
   '(helm-ag-insert-at-point 'symbol)
   '(helm-ag-ignore-buffer-patterrns '("\\.txt\\'" "\\.mkd\\'"))))
  
#+end_src

** Magit

A great interface for git projects. It's much more pleasant to use
than the git interface on the command line. Use an easy keybinding to
access magit.

#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :defer t
  :bind ("C-c g" . magit-status)
  :config
  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session))

(use-package magithub
  :ensure t
  :after magit
  :defer t
  :config
  (magithub-feature-autoinject t)
  (setq magithub-clone-default-directory "~/SourceCode/lisp"))
#+end_src

*** Fullscreen magit

#+BEGIN_QUOTE
The following code makes magit-status run alone in the frame, and then
restores the old window configuration when you quit out of magit.

No more juggling windows after commiting. It's magit bliss.
#+END_QUOTE
[[http://whattheemacsd.com/setup-magit.el-01.html][Source: Magnar Sveen]]

#+begin_src emacs-lisp
  ;; full screen magit-status
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it ;; ad-do-it is a special marker for 'around advice that refers to the wrapped function.
    (delete-other-windows))

  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))
#+end_src

** Gists

#+BEGIN_SRC emacs-lisp
(use-package gist
  :ensure t
  :commands gist-list)
#+END_SRC

** Markdown mode

#+begin_src emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode (("\\.markdown\\'" . markdown-mode)
         ("\\.md\\'"       . markdown-mode)))
#+end_src

** Multiple cursors

We'll also need to ~(require 'multiple-cusors)~ because of [[https://github.com/magnars/multiple-cursors.el/issues/105][an autoload issue]].

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind (("C-S-c C-S-c" . mc/edit-lines)
           ("C->"         . mc/mark-next-like-this)
           ("C-<"         . mc/mark-previous-like-this)
           ("C-c C-<"     . mc/mark-all-like-this)
           ("C-!"         . mc/mark-next-symbol-like-this)
           ("s-d"         . mc/mark-all-dwim)))
#+end_src

** Perspective

Workspaces in Emacs.

#+begin_src emacs-lisp :tangle no
(use-package perspective
  :ensure t
  :defer t
  :config (persp-mode))
#+end_src

** Projectile
[[http://batsov.com/projectile/][Projectile Home]]

#+BEGIN_QUOTE
Project navigation and management library for Emacs.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :commands (projectile-mode projectile-switch-project)
  :bind ("C-c p p" . projectile-switch-project)
  :config
  (projectile-global-mode t)
  (setq projectile-enable-caching t)
  (setq projectile-switch-project-action 'projectile-dired))
#+end_src

** Python

Integrates with IPython.

#+begin_src emacs-lisp

  ;; (use-package ein
  ;;   :defer t
  ;;   :ensure t)

  (use-package jedi
    :ensure t)

  (use-package company-jedi
    :after jedi
    :ensure t)

  (use-package elpy
    :ensure t
    :config
    (setq elpy-rpc-backend "jedi")
    (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "-i --simple-prompt")
    (elpy-enable))

  (use-package jinja2-mode
    :ensure t)

#+end_src

** Racket
   Not using Racket much any more. When I do, drracket is sufficient.
#+begin_src emacs-lisp
;; (use-package racket-mode
;;   :ensure t
;;   :commands racket-mode
;;   :config
;;   (setq racket-smart-open-bracket-enable t))

;; (use-package geiser
;;   :ensure t
;;   :defer t
;;   :config
;;   (setq geiser-default-implementation '(racket)))
#+end_src

** Restclient

See [[http://emacsrocks.com/e15.html][Emacs Rocks! Episode 15]] to learn how restclient can help out with
testing APIs from within Emacs. The HTTP calls you make in the buffer
aren't constrainted within Emacs; there's the
=restclient-copy-curl-command= to get the equivalent =curl= call
string to keep things portable.

#+begin_src emacs-lisp
(use-package restclient
  :ensure t
  :mode ("\\.restclient\\'" . restclient-mode))
#+end_src

** Smartscan

#+BEGIN_QUOTE
Quickly jumps between other symbols found at point in Emacs.
#+END_QUOTE
http://www.masteringemacs.org/article/smart-scan-jump-symbols-buffer


#+begin_src emacs-lisp
  (use-package smartscan
    :ensure t
    :config (global-smartscan-mode 1)
    :bind (("s-n" . smartscan-symbol-go-forward)
           ("s-p" . smartscan-symbol-go-backward)))
#+end_src

** Skewer mode

Live coding for HTML/CSS/JavaScript.

#+begin_src emacs-lisp
(use-package skewer-mode
  :commands skewer-mode
  :ensure t
  :config (skewer-setup))
#+end_src

** Smoothscrolling

This makes it so ~C-n~-ing and ~C-p~-ing won't make the buffer jump
around so much.

#+begin_src emacs-lisp
(use-package smooth-scrolling
  :ensure t)
#+end_src

** Typescript mode

#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :ensure t
  :defer t)
#+END_SRC

** Webmode

#+begin_src emacs-lisp :tangle no
(use-package web-mode
  :ensure t)
#+end_src

** w3m for webby reading
#+BEGIN_SRC emacs-lisp
(use-package w3m
  :ensure t
  :defer t
  :config
  (progn
    (setq browse-url-browser-function 'w3m-browse-url)
    (autoload 'w3m-browse-url "w3m" "Ask a WWW browser to show a URL." t)
    (global-set-key "\C-xm" 'browse-url-at-point)
    (setq w3m-use-cookies t)))
#+END_SRC
** Yasnippet
Yeah, snippets! I start with snippets from [[https://github.com/AndreaCrotti/yasnippet-snippets][Andrea Crotti's collection]]
and have also modified them and added my own.

It takes a few seconds to load and I don't need them immediately when
Emacs starts up, so we can defer loading yasnippet until there's some
idle time.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  (use-package yasnippet-snippets
    :ensure t)
  (use-package common-lisp-snippets
    :ensure t)
  ;; (setq yas-snippet-dirs (concat user-emacs-directory "snippets"))
  (yas-reload-all)
  (yas-global-mode))
#+END_SRC

** YAML mode
#+begin_src emacs-lisp
(use-package yaml-mode
  :ensure t
  :defer t
  :config
  (add-hook 'yaml-mode-hook '(lambda () (ansible 1))))
#+end_src

** Ansible
#+BEGIN_SRC emacs-lisp
  (use-package ansible
    :ensure t
    :defer t
    :config
    (use-package ansible-doc
    :ensure t
    :defer t)
    (use-package ansible-vault
      :ensure t
      :defer t)
    (use-package company-ansible
      :ensure t
      :defer t))
#+END_SRC

** Emmet

According to [[http://emmet.io/][their website]], "Emmet — the essential toolkit for web-developers."

#+begin_src emacs-lisp
(use-package emmet-mode
  :ensure t
  :commands emmet-mode
  :config
  (add-hook 'html-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook 'emmet-mode))
#+end_src

** Zoom-frm

=zoom-frm= is a nice package that allows you to resize the text of
entire Emacs frames (this includes text in the buffer, mode line, and
minibuffer). The =zoom-in/out= command acts similar to the
=text-scale-adjust= command---you can chain zooming in, out, or
resetting to the default size once the command has been initially
called.

Changing the =frame-zoom-font-difference= essentially enables a
"presentation mode" when calling =toggle-zoom-frame=.

This mode is not available in elpa/melpa, so use-package will obviously not work in this case. If you are giving a lot of presentations with emacs, it is very useful, and you can still find the system at [[https://www.emacswiki.org/emacs/zoom-frm.el][Emacs WIKI zoom-frm.el]]. Include it from init.el.

#+begin_src emacs-lisp :tangle no
  ;; (use-package zoom-frm 
  ;;   :ensure t
  ;;   :bind (("C-M-=" . zoom-in/out)
  ;;          ("H-z"   . toggle-zoom-frame)
  ;;          ("s-<f1>" . toggle-zoom-frame))
  ;;   :config
  ;;   (setq frame-zoom-font-difference 10))
#+end_src

** Scratch

Convenient package to create =*scratch*= buffers that are based on the
current buffer's major mode. This is more convienent than manually
creating a buffer to do some scratch work or reusing the initial
=*scratch*= buffer.

#+begin_src emacs-lisp
(use-package scratch
  :ensure t
  :commands scratch)
#+end_src

** Shell pop
#+BEGIN_SRC emacs-lisp
(use-package shell-pop
  :ensure t
  :bind ("M-<f12>" . shell-pop))
#+END_SRC

** Quickrun

#+BEGIN_SRC emacs-lisp
(use-package quickrun
  :defer 10
  :ensure t
  :bind ("H-q" . quickrun))
#+END_SRC

** Visible mode

I found out about this mode by looking through simple.el. I use it to
see raw org-mode files without going to a different mode like
text-mode, which is what I had done in order to see invisible text
(with org hyperlinks). The entire buffer contents will be visible
while still being in org mode.

#+begin_src emacs-lisp
(use-package visible-mode
  :bind (("H-v" . visible-mode)
         ("s-<f2>" . visible-mode)))
#+end_src

** Virtualenvwrapper

#+BEGIN_SRC emacs-lisp
;; (use-package virtualenvwrapper
;;   :ensure t
;;   :defer t
;;   :config
;;   (setq venv-location "~/.virtualenvs"))
#+END_SRC

** XQuery mode

#+BEGIN_SRC emacs-lisp
(use-package xquery-mode
  :ensure t
  :defer t)
#+END_SRC
** LaTeX Extra

#+BEGIN_SRC emacs-lisp
(use-package latex-extra
  :defer t
  :ensure t)
#+END_SRC

** LaTeX Preview Mode

#+BEGIN_SRC emacs-lisp
(use-package latex-preview-pane
  :ensure t
  :defer t)
#+END_SRC
** Undo Tree

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t)
#+END_SRC

** Crux

Collection of Ridiculously Useful eXtensions

#+BEGIN_SRC emacs-lisp
(use-package crux
  :ensure t
  :bind (("C-c o o" . crux-open-with)
         ("C-c u" . crux-view-url)))
#+END_SRC


* Computer-specific settings

Load some computer-specific settings, such as the name and and email
address. The way the settings are loaded is based off of [[https://github.com/magnars/.emacs.d][Magnar
Sveen's]] config.

In my case, the computers I use usually use the same username (my
name, go figure), so instead of basing the specific settings from the
username, I use the hostname. The shell command ~hostname -s~ gets the
hostname for the computer without any "domain information," such as
the ".local" suffix.

Not using this right now.
#+begin_src emacs-lisp
;; (require 'subr-x) ;; #'string-trim
;; (defvar fade/user-settings-dir nil
;;   "The directory with user-specific Emacs settings for this
;;   user.")

;; ;; Settings for currently logged in user
;; (setq fade/user-settings-dir
;;       (concat user-emacs-directory
;;               "users/"
;;               (string-trim (shell-command-to-string "hostname -s"))))
;; (add-to-list 'load-path fade/user-settings-dir)

;; ;; Load settings specific for the current user
;; (when (file-exists-p fade/user-settings-dir)
;;   (mapc 'load (directory-files fade/user-settings-dir nil "^[^#].*el$")))
#+end_src

* Languages
** Generically useful programming utilities
   #+begin_src emacs-lisp
(use-package yatemplate
  :defer t
  :ensure t)   
   #+end_src
** C/Java

I don't like the default way that Emacs handles indentation. For instance,

#+begin_src C
int main(int argc, char *argv[])
{
  /* What's with the brace alignment? */
  if (check)
    {
    }
  return 0;
}
#+end_src

#+begin_src java
switch (number)
    {
    case 1:
        doStuff();
        break;
    case 2:
        doStuff();
        break;
    default:
        break;
    }
#+end_src

Luckily, I can modify the way Emacs formats code with this configuration.

#+begin_src emacs-lisp
(defun my-c-mode-hook ()
  (setq c-basic-offset 4)
  (c-set-offset 'substatement-open 0)   ; Curly braces alignment
  (c-set-offset 'case-label 4))         ; Switch case statements alignment

(add-hook 'c-mode-hook 'my-c-mode-hook)
(add-hook 'java-mode-hook 'my-c-mode-hook)
#+end_src

** Rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :ensure t
  :defer t)
#+END_SRC

** Common Lisp
*** SLY
    Jury is in. Sly is superior to Slime.
    
#+begin_src emacs-lisp
  (use-package sly
    ;; :load-path "~/SourceCode/lisp/sly"
    :defer t
    :commands sly
    :bind ("C-c M-o" . sly-mrepl-clear-repl)
    :init
    (progn
      (setq sly-lisp-implementations
            '((sbcl ("/usr/local/bin/sbcl"))
              (ccl ("/usr/bin/ccl"))
              ;; (ccl64 ("/usr/local/bin/ccl64"))
              (abcl ("/usr/local/src/abcl/abcl"))
              (clisp ("/usr/bin/clisp"))
              (ecl ("/usr/local/bin/ecl"))
              (decl ("/usr/bin/ecl"))
              (clojure ("/usr/bin/Clojure"))))

      (setq sly-kill-without-query-p t
            sly-net-coding-system 'utf-8-unix
            sly-complete-symbol*-fancy t
            common-lisp-hyperspec "~/SourceCode/lisp/HyperSpec"))

    :config
    (progn
      (setq inferior-lisp-program "/usr/local/bin/sbcl")))

  (use-package sly-asdf
    ;; :load-path "~/SourceCode/lisp/sly-asdf"
    :ensure t
    :after sly)

  (use-package sly-macrostep
    :ensure t
    :after sly)

  (use-package sly-named-readtables
    :ensure t
    :after sly)

  (use-package sly-repl-ansi-color
    :ensure t
    :after sly)

  (use-package sly-quicklisp
    :ensure t
    :after sly)

  ;; sly internally integrates company mode, so none of the following are necessary any more.

  ;; (use-package ac-sly
  ;;   :ensure t
  ;;   :after sly)

  ;; (use-package ac-helm
  ;;   :ensure t
  ;;   :after sly)

  ;; (use-package helm-sly
  ;;   :ensure t
  ;;   :after sly
  ;;   :config
  ;;   (progn
  ;;     (global-helm-sly-mode t)
  ;;     (add-hook 'sly-mrepl-hook #'helm-sly-disable-internal-completion)
  ;;     (setq helm-completion-in-region-fuzzy-match t)))
#+end_src

*** Paredit

I spend almost all of my time in emacs writing common lisp code, and in that endeavour, Paredit is the single most useful package in my configuration. It allows me to treat code as structure, moving forms in their entirety. It also ensures that the famous parenthesis are always balanced, and that I usually only have to type the opening 50% of them. This mode is useful in all programming languages for the paren matching features, but it is indespensible if you write any lisp dialect regularly.

#+BEGIN_SRC emacs-lisp
(use-package paredit
  :ensure t
  :config
  (progn
    (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
    (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
    (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
    (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
    ;; (add-hook 'slime-repl-mode-hook       #'enable-paredit-mode)
    (add-hook 'sly-mrepl-mode-hook        #'enable-paredit-mode)
    ;; (add-hook 'slime-mode-hook            #'enable-paredit-mode)
    (add-hook 'clojure-mode-hook          #'enable-paredit-mode)
    (add-hook 'cider-repl-mode-hook       #'enable-paredit-mode)
    ))
#+END_SRC

#+RESULTS:
: t

** Hashicorp Configuration Language
#+BEGIN_SRC emacs-lisp
(use-package hcl-mode
  :defer t
  :ensure t)
#+END_SRC

** JavaScript
  #+BEGIN_SRC elisp
    (use-package js2-mode
      :ensure t
      :init
      (setq js-basic-indent 2)
      (setq-default js2-basic-indent 2
                    js2-basic-offset 2
                    js2-auto-indent-p t
                    js2-cleanup-whitespace t
                    js2-enter-indents-newline t
                    js2-indent-on-enter-key t
                    js2-global-externs (list "window" "module" "require" "buster" "sinon" "assert" "refute" "setTimeout" "clearTimeout" "setInterval" "clearInterval" "location" "__dirname" "console" "JSON" "jQuery" "$"))

      (add-hook 'js2-mode-hook
                (lambda ()
                  (push '("function" . ?ƒ) prettify-symbols-alist)))

      (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode)))
  #+END_SRC

    Color /defined/ variables with [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers-mode]]:

  #+BEGIN_SRC elisp
   (use-package color-identifiers-mode
       :ensure t
       :init
         (add-hook 'js2-mode-hook 'color-identifiers-mode))
  #+END_SRC

    While editing JavaScript is baked into Emacs, it is quite important
  to have [[http://flycheck.readthedocs.org/][flycheck]] validate the source based on [[http://www.jshint.com/][jshint]], and [[https://github.com/eslint/eslint][eslint]].
  Let’s prefer =eslint=:

  #+BEGIN_SRC elisp
    (add-hook 'js2-mode-hook
              (lambda () (flycheck-select-checker "javascript-eslint")))
  #+END_SRC

*** Refactoring JavaScript

    The [[https://github.com/magnars/js2-refactor.el][js2-refactor]] mode should start with =C-c .= and then a two-letter
    mnemonic shortcut.

    * =ef= is =extract-function=: Extracts the marked expressions out into a new named function.
    * =em= is =extract-method=: Extracts the marked expressions out into a new named method in an object literal.
    * =ip= is =introduce-parameter=: Changes the marked expression to a parameter in a local function.
    * =lp= is =localize-parameter=: Changes a parameter to a local var in a local function.
    * =eo= is =expand-object=: Converts a one line object literal to multiline.
    * =co= is =contract-object=: Converts a multiline object literal to one line.
    * =eu= is =expand-function=: Converts a one line function to multiline (expecting semicolons as statement delimiters).
    * =cu= is =contract-function=: Converts a multiline function to one line (expecting semicolons as statement delimiters).
    * =ea= is =expand-array=: Converts a one line array to multiline.
    * =ca= is =contract-array=: Converts a multiline array to one line.
    * =wi= is =wrap-buffer-in-iife=: Wraps the entire buffer in an immediately invoked function expression
    * =ig= is =inject-global-in-iife=: Creates a shortcut for a marked global by injecting it in the wrapping immediately invoked function expression
    * =ag= is =add-to-globals-annotation=: Creates a =/*global */= annotation if it is missing, and adds the var at point to it.
    * =ev= is =extract-var=: Takes a marked expression and replaces it with a var.
    * =iv= is =inline-var=: Replaces all instances of a variable with its initial value.
    * =rv= is =rename-var=: Renames the variable on point and all occurrences in its lexical scope.
    * =vt= is =var-to-this=: Changes local =var a= to be =this.a= instead.
    * =ao= is =arguments-to-object=: Replaces arguments to a function call with an object literal of named arguments. Requires yasnippets.
    * =3i= is =ternary-to-if=: Converts ternary operator to if-statement.
    * =sv= is =split-var-declaration=: Splits a =var= with multiple vars declared, into several =var= statements.
    * =uw= is =unwrap=: Replaces the parent statement with the selected region.

  #+BEGIN_SRC elisp
  (use-package js2-refactor
    :ensure t
    :init   (add-hook 'js2-mode-hook 'js2-refactor-mode)
    :config (js2r-add-keybindings-with-prefix "C-c ."))
  #+END_SRC
  
*** Skewer

    I also configure Skewer for my [[file:emacs-web.org][HTML and CSS]] files, we need to do the
    same for JavaScript:

    #+BEGIN_SRC elisp
  (use-package skewer-mode
     :ensure t
     :init (add-hook 'js2-mode-hook 'skewer-mode))
    #+END_SRC

    Kick things off with =run-skewer=, and then:

   * C-x C-e :: `skewer-eval-last-expression'
   * C-M-x   :: `skewer-eval-defun'
   * C-c C-k :: `skewer-load-buffer'

** Nim                
   #+begin_src emacs-lisp
(use-package nim-mode
  :ensure t)
   #+end_src

* Misc
** Display Time

When displaying the time with =display-time-mode=, I don't care about
the load average.

#+begin_src emacs-lisp
(setq display-time-default-load-average nil)
#+end_src
** Swap Buffer Windows
   #+begin_src emacs-lisp
(use-package buffer-move
  :ensure t
  :config
  (progn
    (global-set-key (kbd "<C-M-s-up>")     'buf-move-up)
    (global-set-key (kbd "<C-M-s-down>")   'buf-move-down)
    (global-set-key (kbd "<C-M-s-left>")   'buf-move-left)
    (global-set-key (kbd "<C-M-s-right>")  'buf-move-right)))
   #+end_src

** Display Battery Mode

See the documentation for =battery-mode-line-format= for the format
characters.

#+begin_src emacs-lisp
(setq battery-mode-line-format "[%b%p%% %t]")
#+end_src

** Docview keybindings

Convenience bindings to use doc-view with the arrow keys.

#+begin_src emacs-lisp
(use-package doc-view
  :commands doc-view-mode
  :config
  (define-key doc-view-mode-map (kbd "<right>") 'doc-view-next-page)
  (define-key doc-view-mode-map (kbd "<left>") 'doc-view-previous-page))
#+end_src

** OS X scrolling

#+begin_src emacs-lisp
(setq mouse-wheel-scroll-amount (quote (0.01)))
#+end_src

** Emacsclient

#+begin_src emacs-lisp
(use-package server
  :config
  (server-start))
#+end_src


